+++
date = "2015-07-26"
title = "Discovering CS"
description = "Recounting, mostly for myself, the journey that brought me to where I am today."

draft = true
+++

Before I took my first Computer Science course at Williams College, I hadn't written a single line of code. While I'd always been relatively adept with computers, fixing problems in elementary school computer lab, configuring my house's wifi, always reveling in setting up a new computer, I'd never known where to start in delving below the user layer. Besides, I had plenty of things to do growing up that satisfied the creator in me. Since at least the days of my great grandfather Roy who was an orthopedic surgeon, my family has had a tradition of woodworking. Most of the furniture in the houses I grew up in was made by my father, and I grew up being rewarded for good behavior with the privilege of learning to use a new tool in the shop. Whether I was building model airplanes, crafting wooden swords and shields, creating rust and aluminum powder for [whatever that was](mythbusters show with the rust/alu mix burning a car in half), or most recently building an electric go-kart/dune buggy, my desire to be building something was always sufficiently satisfied.

My senior year of high school, I had a semester extra in which I could take a course of my choosing at Williams (I was a "townie"). Largely inspired by my recent neighbor, a new professor at the Williams CS department who tossed me little brain teasers like the [traveling salesman problem](wikipedia page?) while I was helping out with yard work at his house, I enrolled in cs134, *An Introduction to Computer Science*. What I was most struck by in that course by how different programming was from my existing experience with computers. I guess on some level I expected what I was to learn in that course to be slightly further along on a continuum of deeper involvement with computers. Instead, I was starting off in completely foreign world.

Teaching introductory computer science is an immensely difficult task, and it was only in retrospect that the organization of that course made sense. My professors struck a good balance between ignoring the unnecessary details, writing them off as "magic," and diving into the important stuff. It was about a third or half way through the semester when everything began to click. Pieces of the jigsaw puzzle started snapping together. The disparate syntactic structures and functions were tied together into a whole. I can recall so clearly the moment I realized that the functions which I was calling from my code were no different from the functions which I had written myself. It was the beginning of creating a mental framework in which I could understand a broader scope of the CS world. While we were taught that course in Java, for my final project I decided to write am iOS application, which at that time meant diving into Objective-C. It was an awesome initial glimpse into the continuity that I continue to see amongst the diverse landscape in CS.

Still, this teaser wasn't enough to pull me in completely. I went into my freshman year of college committed to majoring in Physics, so much so that I talked my way into the Modern Physics course, skipping the intro mechanical which I'd had in high school, even after a mediocre score on the initial placement test. It was a brutal and awesome course with many late nights, but when we got to quantum mechanics, many of the underpinnings and the explanations for demonstrated behaviors just couldn't sit right with me. While I could grasp the mathematics behind the theories we were learning, to this day the explanations proffered by Quantum theory don't seem like the end of the road. Explaining the world as indeterminate probability waves doesn't seem like the final solution. What was also impressed upon me was just how difficult is is to push the edges in Physics. I'm many things, but a genius theoretical physicist didn't seem to be one of them. While much of these thoughts are things I have come to realize after that fact, I think that they all contributed to my return the Computer Science in the spring of my freshman year.

The next course I took was Data Structures. While it gave me a fantastic tool set for the work I am doing today, it still wasn't quite enough to draw me fully into the world of CS. I was following along the tracks of Economics and Political Science, looking for a level of understanding I hadn't found yet. It was the next semester that the dots were connected for me. In my third CS course, Computer Architecture and Organization, I was sold. The bits and pieces I'd learned about low-level networking and bits on the wire were finally connected to the programming languages and theory I'd been playing with so far. Building NAND gates from transistors, learning about the Von Neumann model of computing, pipelining in modern processors, memory management in assembly and C, and so much more. A small moment in that course remains one of my proudest. Our professor happened to omit a bit from lecture that was intended to help with the homework. We had an assignment to design a resettable T-type flip flop circuit. Our professor sent an email out to our class, enumerating a flip flop circuit from which the solution was fairly straightforward. However, I didn't check my email that day (something I still need to get better about), and so it sat unopened in my inbox. Instead, I went to Schow science library and sat down in my usual spot for about 2 hours, hashing out a solution and eventually coming up with something unique, and if memory serves I got full credit on the homework. On a certain level, doing extra work because I didn't read my email might sound frustrating, but being able to get to that solution on my own was such an invigorating experience that I wouldn't trade for anything. It was the potential for moments like that which kept me going in that course.

The final project was to write an interpreter for x86 assembly language in ARM. Furthermore, we were told bluntly that our code would not be read for grading, we would rather be graded on a two dimensional plot of execution time vs space used. What I stumbled across in my design efforts for that project was the concept of compilation. After realizing that in a conversation with my professor, I dived right in. I think he may have given me some sort of warning about the riskiness of the approach, but I believe I just brushed it off with a dose of self-confidence. I spent an increasing amount of my time in the CS lab leading up to the due date for that project, and after my partners for the project, both on the varsity soccer team, headed to texas for the national final four competition, I got around 6 hours of sleep in the final 60 of the project. It was a grind, but after a lot of implementation work, even more bug-squashing, and quadruple checking the dozens of raw hex values I was using to build compiled ARM instructions, I had built a transpiler that was crazy fast, as long as the program it was compiling contained loops! I finished at around 10am the day the project was due, and hung around the lab in my state of delirium. I'm pretty sure after a 2 hour nap that afternoon I went out that night.

Computer Science was a rush. I could build awesome things using my finger tips and a computer, creating massive structures from text on a screen, crunching data, architecting systems. I had discovered a vast playground for my imagination.

In parallel to these discoveries, I was building things that set off a rather remarkable chain of events. As a result of the iOS application I had built at the end of my introductory CS course, I had the opportunity to revamp an old dining application for Williams, which ended up turning into a total rewrite, resulting in [Hungry Eph](https://itunes.apple.com/us/app/hungryeph/id440288933). Next, while I was TA'ing the same Intro CS course, I overheard one of the students talking about an iOS app he was working on for the Williams Business Plan Competition. After learning more about the project, I joined on to [Peck](https://peckapp.com), and when most of the existing team ended up going abroad during the competition, I pitched and won $15,000 to build out the idea over the summer after my sophomore year of college. I recruited and hired a team of my peers from the CS department to build out the concept over the summer, and we built a Ruby on Rails backend, a fully functional iOS app, and a good portion of a working Android app. While I didn't realize it at the time, after the summer I was totally burnt. I had been on a schedule of waking up at 8, being in work by 9, working til 6, then coming home, eating, and working til past midnight before going to bed. My muscles were atrophying as fast as I was learning Ruby. There was one Sunday about halfway through the summer that about mid afternoon I realized it was the first time I was going a day without working on Peck. I had the pedal to the floor. Working in parallel to us was a company working on the evolution of a desktop cleanup application called Tidy, entered by Jason Briggs in the same Business plan competition I had won. After the competition, we had found outside funding with the CEO of a massive company plagued by disorganized files. He had also hired a team and they were working away next door to us all summer long.

After the summer was over, I went abroad to AIT-Budapest for a computer science program. That semester contained some of the happiest months of my life, due to the amazing people I spent it with, the magic of that city, the quality of the AIT program, and very likely how much the freedom I felt there contrasted with the summer prepending it. Still, those experiences are for future posts. What brings me to today is Jason asking me to join what has become Meta. It was a decision I weighed with my friend there, Hungarian entrepreneurs, my professors back at Williams, and most crucially my parents, and in the end the opportunity was too good to pass on. Jason sold me on his vision and determination, and today I'm working night and day as the CTO and Co-Founder of Meta, building the future of search, the Google for your files, a platform to achieve singularity in file management. We're building a vision. There's nothing more pure and exciting that being able to execute on a dream.
