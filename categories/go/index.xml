<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Go on Aaron Taylor</title>
    <link>http://localhost:1313/categories/go/</link>
    <description>Recent content in Go on Aaron Taylor</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 20 Jun 2015 22:23:41 -0400</lastBuildDate>
    <atom:link href="http://localhost:1313/categories/go/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Linking Dynamic C&#43;&#43; Libraries with Go</title>
      <link>http://localhost:1313/blog/cgolinking/</link>
      <pubDate>Sat, 20 Jun 2015 22:23:41 -0400</pubDate>
      
      <guid>http://localhost:1313/blog/cgolinking/</guid>
      <description>

&lt;p&gt;These days, I spend a lot of time working with, designing, and implementing APIs. Since &lt;a href=&#34;https://meta.sc&#34;&gt;Meta&lt;/a&gt; is a microservices based application, the contracts that those APIs provide are crucial to designing the interactions with them. Quickly, maintaining good documentation and client libraries becomes nearly as important of a part of the applications as the code itself. Each step forward in functionality must provide solid footing to keep on building.&lt;/p&gt;

&lt;p&gt;A spectacular tool that we have been using is &lt;a href=&#34;https://apiary.io&#34;&gt;Apiary&lt;/a&gt;, a service that provides API documentation through a super set of markdown that is fully parsable, providing mocked APIs and examples through a single set of documentation. The format of this markdown documentation is &lt;a href=&#34;https://apiblueprint.org&#34;&gt;API Blueprint&lt;/a&gt; format, for which the documentation and a rich set of parsing libraries and tooling has been released under the MIT license.&lt;/p&gt;

&lt;h3 id=&#34;a-confluence-of-interests:f0f98a633f4540118f1ad2a10a32d79e&#34;&gt;A Confluence of Interests&lt;/h3&gt;

&lt;p&gt;The core parsing library for the API BLueprint format is called &lt;a href=&#34;https://github.com/apiaryio/snowcrash&#34;&gt;Snow Crash&lt;/a&gt; and is written in C++. Built on top of this library is a tool called &lt;a href=&#34;https://github.com/apiaryio/drafter&#34;&gt;Drafter&lt;/a&gt;, also a C++ library, which provides a cleaner interface to interact with the primary purpose of Snow Crash, parsing human readable markdown into json.&lt;/p&gt;

&lt;p&gt;There are two client libraries currently available for drafter. &lt;a href=&#34;https://github.com/apiaryio/protagonist&#34;&gt;Protagonist&lt;/a&gt; is written in Node.js, and &lt;a href=&#34;https://github.com/apiaryio/redsnow&#34;&gt;RedSnow&lt;/a&gt; is written in Ruby. I mostly am writing Go these days, so this seemed like a great opportunity to add a Go client library for the core Snow Crash parsing library.&lt;/p&gt;

&lt;p&gt;Since the core library is written in C++, this means that it would also be a chance to work with &lt;a href=&#34;http://golang.org/cmd/cgo/&#34;&gt;cgo&lt;/a&gt;, the Go language&amp;rsquo;s too to interact with C code. This is something that&amp;rsquo;s been on my want-to-do list for a while, but this seemed like the perfect opportunity to dive in.&lt;/p&gt;

&lt;h2 id=&#34;experimenting-with-cgo:f0f98a633f4540118f1ad2a10a32d79e&#34;&gt;Experimenting with cgo&lt;/h2&gt;

&lt;p&gt;The Go blog has a great post to get started with C and Go called &lt;a href=&#34;http://blog.golang.org/c-go-cgo&#34;&gt;C? Go? Cgo!&lt;/a&gt; that I used to get initially up and running.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

/*
#include &amp;lt;stdlib.h&amp;gt;
*/
import &amp;quot;C&amp;quot;
import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;time&amp;quot;
)

func Random() int {
    return int(C.random())
}

func Seed(i int) {
    C.srandom(C.uint(i))
}

func main() {
    fmt.Printf(&amp;quot;Deterministic random: %v\n&amp;quot;, Random())
    Seed(int(time.Now().Unix()))
    fmt.Printf(&amp;quot;Seeded random: %v\n&amp;quot;, Random())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;remembering-c:f0f98a633f4540118f1ad2a10a32d79e&#34;&gt;Remembering C&lt;/h2&gt;

&lt;p&gt;The existing wrapper libraries use the Drafter source as a git submodule which is compiled into a shared library for use by the wrapper. Most of my experience with C/C++ is either with simple projects in a single folder with only standard library dependencies, or from within an IDE that handles most of the complexities of compilation for you. Since there would be a bigger manual component to this project, creating a simple proof of concept interface written in C seemed like a prudent first step.&lt;/p&gt;

&lt;p&gt;I would be wrapping the &lt;a href=&#34;https://github.com/apiaryio/drafter/blob/master/README.md#c-interface&#34;&gt;C-Interface&lt;/a&gt; described in the project&amp;rsquo;s README file, so getting the example code up and running seemed to be a good start.&lt;/p&gt;

&lt;h4 id=&#34;drafter-c-based-test-code:f0f98a633f4540118f1ad2a10a32d79e&#34;&gt;Drafter C-based test code&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;quot;cdrafter.h&amp;quot;

int main(int argc, char const *argv[])
{
    const char* source = &amp;quot;# My API\n## GET /message\n + Response 200 (text/plain)\n\n        Hello World\n&amp;quot;;
    char *result = NULL;
    int ret = drafter_c_parse(source, 0, &amp;amp;result);

    printf(&amp;quot;Result: %s\n&amp;quot;, ret == 0 ? &amp;quot;OK&amp;quot; : &amp;quot;ERROR&amp;quot;);
    printf(&amp;quot;Serialized JSON result:\n%s\n&amp;quot;, result);

    free(result); /* we MUST release allocted memory for result */
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;ll be doing a two step compilation process here to allow for proper linking between the C code and the shared library. With the above code snippet in a file called &lt;code&gt;ctest.c&lt;/code&gt;, we can compile that into an object file using the following command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gcc -Wall -c ctest.c -I./drafter/src/ -I./drafter/ext/snowcrash/src/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;-I&lt;/code&gt; flags add the specified directory to the include search path, allowing for the &lt;code&gt;cdrafter.h&lt;/code&gt; file and the headers which it contains to be used in creating the object file.&lt;/p&gt;

&lt;p&gt;After this command is executed, we end up with a file called &lt;code&gt;ctest.o&lt;/code&gt;, which is the object file for the c code above. This &lt;code&gt;.o&lt;/code&gt; file needs to be again compiled in order to properly link it to the dynamic library for drafter. This is the tricky part. A big help to me here was looking at the how the RedSnow library sets up ruby&amp;rsquo;s FFI module to interact with Drafter&amp;rsquo;s C interface.&lt;/p&gt;

&lt;h3 id=&#34;detour-into-ruby:f0f98a633f4540118f1ad2a10a32d79e&#34;&gt;Detour into Ruby&lt;/h3&gt;

&lt;p&gt;From looking at &lt;a href=&#34;https://github.com/apiaryio/redsnow/blob/master/lib/redsnow/binding.rb&#34;&gt;binding&lt;/a&gt; file for the RedSnow library, two things became clear. First, there were platform dependent aspects of this compilation process. These will be especially important in setting up CI for my library later on. The other element present here was that the dynamic library itself was not created by the build process described in Drafter&amp;rsquo;s README. looking at the &lt;a href=&#34;https://github.com/apiaryio/redsnow/blob/master/Rakefile&#34;&gt;&lt;code&gt;Rakefile&lt;/code&gt;&lt;/a&gt; for RedSnow, I found a special configuration option which prompted the creation of a shared library, a &lt;code&gt;--shared&lt;/code&gt; flag on the build configuration for Drafter.&lt;/p&gt;

&lt;p&gt;Still, there were a few more uncertainties. Being unfamiliar with the specifics of dynamic library compilation, there were a few interactions with Ruby&amp;rsquo;s FFI library that I wanted to understand more. So, taking inspiration from Go&amp;rsquo;s best practice of reading the source code, I dived into the &lt;a href=&#34;https://github.com/ffi/ffi&#34;&gt;FFI source&lt;/a&gt;. The &lt;a href=&#34;https://github.com/ffi/ffi/blob/master/lib/ffi/platform.rb&#34;&gt;&lt;code&gt;lib/ffi/platform.rb&lt;/code&gt;&lt;/a&gt; file contained most of what I was looking for. The definition of &lt;code&gt;LIBSUFFIX&lt;/code&gt; and the way that platform tests were handled would be very useful later on. For now, I was that Mac dynamic libraries have a &lt;code&gt;.dylib&lt;/code&gt; extension. That and the compilation configuration were just what I needed.&lt;/p&gt;

&lt;h3 id=&#34;back-to-c:f0f98a633f4540118f1ad2a10a32d79e&#34;&gt;Back to C&lt;/h3&gt;

&lt;p&gt;Armed with this knowledge of how the Ruby wrapper library handled setting up the C bindings, I hashed through getting my simple C example working.&lt;/p&gt;

&lt;p&gt;The next step was to compile the shared library for Drafter. Using the &lt;code&gt;./configure --shared&lt;/code&gt; and &lt;code&gt;make&lt;/code&gt; commands that drafter comes with. Behind the scenes, Drafter and its dependencies use the &lt;a href=&#34;https://code.google.com/p/gyp/&#34;&gt;GYP&lt;/a&gt; build system to configure their compilation process. On Mac, that build process creates a &lt;code&gt;libdrafter.dylib&lt;/code&gt; file.&lt;/p&gt;

&lt;p&gt;Specifying the location of this file requires custom flags for the compiler command. With a bit of searching I was able to find the &lt;code&gt;-L&lt;/code&gt; flag, which, similarly to the &lt;code&gt;-I&lt;/code&gt; flag, specifies a search directory for the compilation process as a whole. By specifying both Drafter&amp;rsquo;s build directory and dynamic library itself, we had a compiling C program!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gcc ctest.o -L./drafter/build/out/Release/ -ldrafter -o ctest
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Unfortunately, a compiling C program doesn&amp;rsquo;t always mean a running C program. I was getting an error of the form:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./ctest
dyld: Library not loaded: /usr/local/lib/libdrafter.dylib
  Referenced from: /Users/ataylor/go/src/github.com/kujenga/gosnow/./ctest
  Reason: image not found
make: *** [test] Trace/BPT trap: 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After looking into the usage of &lt;code&gt;-rpath&lt;/code&gt; or &lt;code&gt;@rpath&lt;/code&gt;, which allows for the specification of runtime search paths within the binary, without much success, the simplest option that I came across was to put a soft link from the location of the custom compiled dynamic library for Drafter to the global system library location, &lt;code&gt;/usr/local/lib/&lt;/code&gt; on Mac, effectively installing this library on my computer.&lt;/p&gt;

&lt;p&gt;Finally, it worked! I just about jumped for joy. After hours of tweaks and research, I was calling into a custom compiled dynamic library, something I hadn&amp;rsquo;t a clue about just a day earlier.&lt;/p&gt;

&lt;h2 id=&#34;translating-to-go:f0f98a633f4540118f1ad2a10a32d79e&#34;&gt;Translating to Go&lt;/h2&gt;

&lt;p&gt;After successfully creating a C version of the basic functionality that I wanted to implement, and with a basic understanding of Go&amp;rsquo;s interop with C, I started porting the example code to a Go version with the same functionality.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;https://golang.org/cmd/cgo/&#34;&gt;cgo documentation&lt;/a&gt; specified a variety of pseudo directives that can be used for customizing the behavior of GCC as executed by Go. The two most relevant seemed to be &lt;code&gt;CFLAGS&lt;/code&gt;, for the initial compilation of the C code, and &lt;code&gt;LDFLAGS&lt;/code&gt;, for linking libraries with the compiled code.&lt;/p&gt;

&lt;p&gt;I simply copied the options for the first compilation step for the C program as the value for &lt;code&gt;CFLAGS&lt;/code&gt;, and for options for the second compilation step as the value for &lt;code&gt;LDFLAGS&lt;/code&gt;, and to my great delight, it worked! The jump from C to Go had been the easiest part so far.&lt;/p&gt;

&lt;h3 id=&#34;writing-tests:f0f98a633f4540118f1ad2a10a32d79e&#34;&gt;Writing Tests&lt;/h3&gt;

&lt;p&gt;I got the code up and running as a single file using the command &lt;code&gt;go run main.go&lt;/code&gt;, treating it as a single file. Since my goal was to have this be a wrapper library, my next logical step was to convert this into a package with some tests! Unfortunately, this change introduced another error.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;duplicate symbol _main in:
    $WORK/github.com/kujenga/gosnow/_test/_obj_test/_cgo_main.o
    $WORK/github.com/kujenga/gosnow/_test/_obj_test/ctest.o
ld: 1 duplicate symbol for architecture x86_64
clang: error: linker command failed with exit code 1 (use -v to see invocation)
FAIL    github.com/kujenga/gosnow [build failed]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The issue here was that after changing the go code to be a package, the Go compiler was treating my unrelated C test program as part of the package, and since Go creates its own &lt;code&gt;main&lt;/code&gt; method in tests, there was a duplicate main method. Moving the C file to a subdirectory got things back up and running.&lt;/p&gt;

&lt;h2 id=&#34;continuous-integration:f0f98a633f4540118f1ad2a10a32d79e&#34;&gt;Continuous Integration&lt;/h2&gt;

&lt;p&gt;These days, it seems like any open source library or project worth its salt has a continuous integration setup and test coverage metrics proudly displayed at the top of its README file.&lt;/p&gt;

&lt;h2 id=&#34;next-steps:f0f98a633f4540118f1ad2a10a32d79e&#34;&gt;Next Steps&lt;/h2&gt;

&lt;h3 id=&#34;the-code:f0f98a633f4540118f1ad2a10a32d79e&#34;&gt;The Code&lt;/h3&gt;

&lt;p&gt;My code is up on Github at &lt;a href=&#34;https://github.com/kujenga/gosnow&#34;&gt;github.com/kujenga/gosnow&lt;/a&gt;. Like the library it wraps, it is MIT Licensed.&lt;/p&gt;

&lt;h3 id=&#34;references:f0f98a633f4540118f1ad2a10a32d79e&#34;&gt;References&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.golang.org/c-go-cgo&#34;&gt;The Go Blog - C? Go? Cgo!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.goinggo.net/2013/08/using-c-dynamic-libraries-in-go-programs.html&#34;&gt;Going Go - Using C Dynamic Libraries In Go Programs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>